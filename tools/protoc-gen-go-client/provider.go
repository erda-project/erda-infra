// Copyright 2021 Terminus
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"sort"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	servicehubPackage = protogen.GoImportPath("github.com/erda-project/erda-infra/base/servicehub")
	stringsPackage    = protogen.GoImportPath("strings")
	reflectPackage    = protogen.GoImportPath("reflect")
	fmtPackage        = protogen.GoImportPath("fmt")
)

func genProvider(gen *protogen.Plugin, files []*protogen.File, root *protogen.File, sources string) error {
	servicesMap, packagesMap := make(map[string]*protogen.Service), make(map[string]struct{})
	var services, packages []string
	for _, f := range files {
		if len(f.Desc.Package()) > 0 {
			packagesMap[string(f.Desc.Package())] = struct{}{}
		}
		for _, ser := range f.Services {
			name := strings.TrimRight(string(f.Desc.Package()), ".") + "." + ser.GoName
			services = append(services, name)
			servicesMap[name] = ser
		}
	}
	for pkg := range packagesMap {
		packages = append(packages, pkg)
	}
	sort.Strings(packages)
	sort.Strings(services)

	const filename = "provider.go"
	const pkgname = "client"
	g := gen.NewGeneratedFile(filename, pkgname)
	g.P("// Code generated by ", genName, ". DO NOT EDIT.")
	g.P("// Source: ", sources)
	g.P()
	g.P("package ", pkgname)
	g.P()
	g.P("var dependencies = []string{")
	for _, pkg := range packages {
		g.P(strconv.Quote("grpc-client@"+pkg), ",")
	}
	g.P("	\"grpc-client\",")
	g.P("}")
	g.P()
	g.P("type provider struct {")
	g.P("	client Client")
	g.P("}")
	g.P()
	g.P("func (p *provider) Init(ctx ", servicehubPackage.Ident("Context"), ") error {")
	g.P("	var conn ", transgrpcPackage.Ident("ClientConnInterface"))
	g.P("	for _, dep := range dependencies {")
	g.P("		c, ok := ctx.Service(dep).(", transgrpcPackage.Ident("ClientConnInterface"), ")")
	g.P("		if ok {")
	g.P("			conn = c")
	g.P("			break")
	g.P("		}")
	g.P("	}")
	g.P("	if conn == nil {")
	g.P("		return ", fmtPackage.Ident("Errorf"), "(\"not found connector in (%s)\", ", stringsPackage.Ident("Join"), "(dependencies, \", \"))")
	g.P("	}")
	g.P("	p.client = New(conn)")
	g.P("	return nil")
	g.P("}")
	g.P()
	g.P("var (")
	g.P("	clientsType = ", reflectPackage.Ident("TypeOf"), "((*Client)(nil)).Elem()")
	for _, file := range files {
		for _, ser := range file.Services {
			g.P(lowerCaptain(ser.GoName+"ClientType"), " = ", reflectPackage.Ident("TypeOf"), "((*", file.GoImportPath.Ident(ser.GoName+"Client"), ")(nil)).Elem()")
			g.P(lowerCaptain(ser.GoName+"ServerType"), " = ", reflectPackage.Ident("TypeOf"), "((*", file.GoImportPath.Ident(ser.GoName+"Server"), ")(nil)).Elem()")
		}
	}
	g.P(")")
	g.P()
	g.P("func (p *provider) Provide(ctx ", servicehubPackage.Ident("DependencyContext"), ", args ...interface{}) interface{} {")
	g.P("	var opts []", grpcPackage.Ident("CallOption"))
	g.P("	for _, arg := range args {")
	g.P("		if opt, ok := arg.(", grpcPackage.Ident("CallOption"), "); ok {")
	g.P("			opts = append(opts, opt)")
	g.P("		}")
	g.P("	}")
	if len(services) > 0 {
		g.P("switch ctx.Service() {")
		g.P("	case ", strconv.Quote(string(root.Desc.Package())+"-client"), ":")
		g.P("		return p.client")
		for _, name := range services {
			ser := servicesMap[name]
			g.P("case ", strconv.Quote(name), ":")
			g.P("	return &", lowerCaptain(ser.GoName+"Wrapper"), "{client:p.client.", ser.GoName, "() , opts: opts}")
			g.P("case ", strconv.Quote(name+".client"), ":")
			g.P("	return p.client.", ser.GoName, "() ")
		}
		g.P("}")
	}
	g.P("	switch ctx.Type() {")
	g.P("		case clientsType:")
	g.P("			return p.client")
	for _, file := range files {
		for _, ser := range file.Services {
			g.P("case ", lowerCaptain(ser.GoName+"ClientType"), ":")
			g.P("	return p.client.", ser.GoName, "() ")
			g.P("case ", lowerCaptain(ser.GoName+"ServerType"), ":")
			g.P("	return &", lowerCaptain(ser.GoName+"Wrapper"), "{client:p.client.", ser.GoName, "() , opts: opts}")
		}
	}
	g.P("	}")
	g.P("	return p")
	g.P("}")
	g.P()
	g.P("func init() {")
	g.P("	", servicehubPackage.Ident("Register"), "(", strconv.Quote(string(root.Desc.Package())+"-client"), ", &", servicehubPackage.Ident("Spec"), "{")
	g.P("		Services: []string{")
	for _, name := range services {
		g.P("		", strconv.Quote(name), ",")
	}
	g.P("		", strconv.Quote(string(root.Desc.Package())+"-client"), ",")
	g.P("		},")
	g.P("		Types: []", reflectPackage.Ident("Type"), "{")
	g.P("			clientsType,")
	g.P("			// client types")
	for _, file := range files {
		for _, ser := range file.Services {
			g.P(lowerCaptain(ser.GoName+"ClientType"), ",")
		}
	}
	g.P("			// server types")
	for _, file := range files {
		for _, ser := range file.Services {
			g.P(lowerCaptain(ser.GoName+"ServerType"), ",")
		}
	}
	g.P("		},")
	g.P("		OptionalDependencies: dependencies,")
	g.P("		Creator: func() ", servicehubPackage.Ident("Provider"), " {")
	g.P("			return &provider{}")
	g.P("		},")
	g.P("	})")
	g.P("}")
	return nil
}
